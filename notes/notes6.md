Ab aage kya ! 

To create a middleware using Multer, we can handle file uploads from the client side and then upload those files to Cloudinary using your existing function. 


This middleware will ensure that the file is processed and uploaded before continuing with the rest of your logic.


jaha jaha humein file upload capabilites ki jarurat hogi waha pe multer ko inject krdenge


Cloudinary is a utility for uploading files, but the file upload itself should be managed with a middleware in your server. 


So, you need to create a middleware that handles file uploading (via Multer), 
processes the file (uploads to Cloudinary), and then moves to the next step in the pipeline.


sabse pehle multer import kra lete h , then uske baad konsi destination woh usko batado

For more detailed study 

https://github.com/expressjs/multer?tab=readme-ov-file


frontend pe aise krna hai

```bash
<form action="/profile" method="post" enctype="multipart/form-data">
  <input type="file" name="avatar" />
</form>
```


sample Example

```bash

const express = require('express')
const multer  = require('multer')
const upload = multer({ dest: 'uploads/' })

const app = express()

app.post('/profile', upload.single('avatar'), function (req, res, next) {
  // req.file is the `avatar` file
  // req.body will hold the text fields, if there were any
})

```
Others uploads Realted stuff

- upload.array('photos', 12)
- upload.fields([{ name: 'avatar', maxCount: 1 }, { name: 'gallery', maxCount: 8 }])
- upload.none()


destination :: The folder to which the file has been saved -->	DiskStorage ( we prefer )


A Buffer of the entire file -->	MemoryStorage


hum puri ki puri entire file ko memory mein bhi store kr skte h and diskStorage mein bhi 


storing large files in memory can quickly fill up the system's memory if multiple files are uploaded, 

leading to potential performance issues or even out of memory errors



Memory Storage (memoryStorage) is faster but limited by server memory and can cause issues with large files.


Disk Storage (diskStorage) is more scalable, stores files on the disk, and is the recommended approach for handling large files or multiple file uploads.



ye jo ek user se reqquest aa rhi hai , ek  file access mil jata hai jiske andar saari files humein mil jaati h


req ke andar jo bhi body mein ayega jo bhi json data wo mil hi jaata hai and agar file bhi aa rhi hai , whi pe multer use hota h


kyuki req.body ke andar json data toh humne configure krdiya h , but file nhi hoti h
isliye multer use hota h , ya phir fileupload-express wo use hota h



In Multer, when you're using DiskStorage to store files, the file object returned in the callback contains information about the uploaded file.

```bash

{
  fieldname: 'file',         
  originalname: 'image.png', 
  encoding: '7bit',          
  mimetype: 'image/png',    
  destination: 'uploads/',   
  filename: 'abc123.png',  
  path: 'uploads/abc123.png' 
}

```

- fieldname: The name of the form field associated with the file (e.g., file).

- originalname: The name of the file as it was uploaded by the user

- encoding: The encoding type used for the file upload (typically 7bit)

- mimetype: The MIME type of the file, which indicates the file's type (e.g., image/png).

- destination: The directory where the file is stored.

- filename: The name of the file as it is saved on the disk (can be generated by Multer or specified).

- path: The full file path, combining the destination directory and the filename.

---------------------------------------------

jab hum routes and controllers likhenge , agar hum expect kr rhe ki uss route pe files ayengi toh main uss route ke andar jaake , storage method call krayenge , toh humein file mil jayegi 


and uss file ko kaise access krna hai and kaise dena hai wo hum dekhenge


---------------------------------------------


 HTTP :: HyperText Transfer Protocol

  - Ek communication protocol hai jo client (browser) aur server ke beech mein clear text mein data transfer karta hai.
  
  - Ismein data encrypt nahi hota — koi beech mein intercept kare toh data easily padhe ja sakta hai.


HTTPS :: HyperText Transfer Protocol Secure 
   
   - HTTP ka secure version hai.

   - Ismein data encrypt hota hai, jaise key lagakar EX-OR operations (aur aur bhi encryption techniques) use karke data ko unreadable banaya jata hai.

   - Jab data server ya client tak pahuchta hai, toh woh decrypt hokar readable ban jata hai.

   - Encryption and Decryption ke liye mainly TLS (Transport Layer Security) ya pehle SSL (Secure Sockets Layer) ka use hota hai.


Major Difference ::

   - Bas protocol mein security add hui hai.

   - Jo basic communication technology aur rules hain (HTTP methods jaise GET, POST, PUT, DELETE) — woh mostly same hi hain.


Data Transfer ka Logic

   - Jab hum koi text ya information transfer karte hain, woh different formats (HTML, JSON, XML etc.) mein ho sakta hai.

   - Kaise transfer karna hai — ispe depend karta hai ki hum kaunsa format use karte hain aur kis tarah efficiently bhejte hain.



Optimization ke Liye DSA (Data Structures and Algorithms)

   - Hum optimized tarike se data bhejna chahte hain.

   - Aise data structures avoid karte hain jo heavy ya expensive ho.

   - Yahan pe DSA knowledge kaam aati hai — kaise data ko efficiently store aur send karein.



System Level Pe View

Jab computers/servers aapas mein network ke upar communicate karte hain

  - Networking knowledge zaroori hoti hai (kaise packets bante hain, kaise routing hoti hai, etc.)

  - Operating System (OS) bhi important hai (data ko kaise hold kare, process kare, memory manage kare, etc.)



---------------------------------------------

URL (Uniform Resource Locator)

-  Ye location batata hai kisi resource ki.

-  Matlab resource kahan available hai (address deta hai).

-  Example: https://www.example.com/page.html



URN (Uniform Resource Name)


- Ye naam batata hai resource ka, bina uski location bataye.

- Resource ka ek unique name hota hai jo globally unique rahe.

- Example: urn:isbn:0451450523
(ye ek book ka ISBN number hai, location ka kuch nahi batata)



URI (Uniform Resource Identifier)


- URI ek umbrella term hai 
URI = URL ya URN (ya dono ka combination).

- URI ka kaam hai identify karna kisi resource ko, chahe wo location ke through ho (URL) ya name ke through ho (URN).


---------------------------------------------


- Jab hum kisi resource (server, database, service) se baat karna chahte hain —
sabse pehle humein uska address (location) chahiye hota hai.


- Address mil gaya matlab ab hum jaante hain kahan pe contact karna hai.

- Ab kis tarike se contact karna hai (kaunsa protocol use karna hai) — wo depend karta hai situation pe.



Location ka Format Protocol ke According Change Hota Hai


HTTP/HTTPS: Web servers ke liye.
Example: https://www.example.com


MongoDB: Database ke liye alag tarike ka connection string hota hai.
Example: mongodb+srv://username:password@cluster0.mongodb.net/dbname


FTP: Files transfer karne ke liye.
Example: ftp://ftp.example.com/files


WS/WSS (WebSocket Secure): Real-time communication ke liye.
Example: wss://realtime.example.com


SSH: Remote server access ke liye.
Example: ssh://user@host


---------------------------------------------


HTTP Headers kya hote hain?


Jab bhi hum koi HTTP request bhejte hain (ya receive karte hain), uske saath kuch additional information bhejna zaroori hota hai.


Ye information key-value pairs ke form mein hoti hai , jise hum HTTP Headers kehte hain.


Jaise jab hum ek file bhejte hain, toh sirf file ka data nahi jaata, uske sath kuch meta information bhi jaati hai:
    
  - File ka naam kya hai (filename)

  - File ka size kitna hai (content-length)

  - File kab banayi gayi (created-at)

  - File kab last modify hui (last-modified)


Metadata = Additional info about actual data

Ye saara metadata, HTTP ke andar headers ke form mein send/receive hota hai.




Important points about HTTP Headers:

   - Ye key-value pairs hote hain.

   - Kuch headers standard hote hain (already defined jaise Content-Type, Authorization, Accept, User-Agent, etc.)

   - Hum apne custom headers bhi bana sakte hain (for example, x-auth-token: yourTokenHere).



Request Headers ke examples:

   - Agar request browser se aa rahi hai → kuch specific headers honge jaise User-Agent, Accept-Language.

   - Agar request Postman ya Thunderclient se aa rahi hai → kuch alag headers hote hain jaise Postman-Token, Content-Type.

   - Agar programmatically (jaise fetch, axios, XMLHttpRequest) request bheji ja rahi hai → toh hum manually headers set kar sakte hain.



Har jagah pe thoda different headers send hote hain based on kaun request kar raha hai aur kya expect kiya ja raha hai server se.



Summary:

-  Jab bhi HTTP ke through koi request ya response hota hai, uske sath headers jaate hain — ye headers metadata ke tarah kaam karte hain. 

- Ye server ko aur client ko batate hain ki data ko kaise handle karna hai.



Browser, Postman, ya program har ek apni-apni tarah ke headers bhejte hain taaki server ko pata chal sake:

   - Request kis type ki hai
   - Request kis client se aayi hai
   - Data ka format kya expect karna hai

---------------------------------------------



Jaise request ke saath request headers jaate hain, waise hi jab server reply karta hai, toh response headers ke sath karta hai.

response mein status code bhejta hai


- 200 OK → Sab kuch theek, data mil gaya.

- 404 Not Found → Jo resource maanga tha, wo nahi mila.

- 500 Internal Server Error → Server ke andar kuch error ho gaya.

- 401 Unauthorized → Tumhara authentication nahi hua.

Status code + Status message se pata chalta hai server kya keh raha hai.



Response Headers (Metadata about response)


```yaml
content-type: text/html; charset=UTF-8 
content-length: 5321
server: gws
cache-control: private, max-age=0
set-cookie: SID=abcd1234; Path=/; Secure; HttpOnly
date: Sat, 26 Apr 2025 08:00:00 GMT
```

Note : yaml file  is commonly used for configuration files and in applications where data is being stored or transmitted


  - Response kis format mein hai (HTML, JSON, etc.)

	- Data ka size bytes mein

	- Kaunsa server software chal raha hai (jaise Apache, Nginx, Google Web Server)

	- Client ko koi cookie set karne ka instruction

	- Response ko cache karna hai ya nahi

  - Server ne kab ye response bheja


---------------------------------------------

```scss
[Client] --> Request (headers ke sath) --> [Server]
[Server] --> Response (status + headers + body) --> [Client]
```


- Jaise jab browser mein tum kuch URL likhte ho aur 404 aata hai, toh browser response ke status code aur headers ko dekh kar samajh jaata hai ki

"Page nahi mila, isiliye 404 ka page dikhao."


- Ya jab image ya video chalti hai, toh browser response ke content-type: image/png ya video/mp4 dekh ke samajh jaata hai ki:

"Isko video player mein play karna hai."



Server bhi response ke sath headers bhejta hai, jo client ko batate hain ki kya mila, kaise mila, aur kaise handle karna hai.

---------------------------------------------



HTTP Headers basically communication ke rules aur context set karte hain —
ki server aur client ek dusre ko clearly samajh saken.


Aur jaise tumne kaha — sirf ek kaam nahi hai headers ka.
Alag-alag use-cases hote hain


1. Caching  

   - Headers decide karte hain ki data cache hoga ya nahi.

Example headers:

   - Cache-Control: max-age=3600 → 1 ghante tak cache kar lo.

   - ETag: "xyz123" → Agar data same hai toh browser purana data hi dikhaye.

   - Last-Modified: Sat, 26 Apr 2025 07:00:00 GMT


Purpose: Server load kam karna aur fast loading experience dena.



2. Authentication & Security

   - Headers user ko verify karne ke liye use hote hain.


Example headers:

  - Authorization: Bearer <token> → JWT token se verify karte hain.

  - Set-Cookie: sessionId=abc123; HttpOnly → Session based auth ke liye.

  - X-CSRF-Token: randomtoken123 → CSRF attacks se bachaav.



Purpose: Check karna ki user authorized hai ya nahi.



3. User State Management

    - User ka current state ya progress track karte hain.

Example headers:

   - Cookie mein cart ka data store (cartId=12345)

   - Logged in user ya guest user ka token

   - x-user-role: admin / user / guest


Purpose: Personalised experience dena (jaise cart mein pehle se products dikha dena).



4. Content Negotiation

   - Decide karte hain ki data kis format mein exchange hoga.


Example headers:

  - Accept: application/json → Client expect kar raha hai JSON.  or text/html

  - Content-Type: application/json → Server bol raha hai ki JSON bheja hai.



Purpose: Data exchange properly format mein ho.



5. Informational / Meta Info

Request aur Response ke baare mein extra information dete hain.

Example Headers

   - User-Agent: Mozilla/5.0... → Client kaunsa device/browser use kar raha hai.

   - Referer: https://google.com → Request ka source kya tha.

   - Server: Apache/2.4.29 → Backend server ka software kya hai.



Purpose: Analytics, debugging, optimization ke liye help milti hai.





" HTTP Headers = Communication ke hidden messengers. "

Ye data ka format, security, state, caching, authentication, sab kuch silently manage karte hain taaki client aur server ek dusre ko samajh sakein bina confusion ke. 


